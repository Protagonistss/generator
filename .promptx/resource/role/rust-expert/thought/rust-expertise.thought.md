<thought>
  <exploration>
    ## Rust 核心领域探索
    
    ### 所有权系统深度理解
    - **借用检查器机制**: 编译时内存安全保证的核心原理
    - **生命周期标注**: 复杂引用关系的管理策略
    - **移动语义**: 零成本抽象的实现基础
    
    ### 类型系统高级特性
    - **泛型约束**: trait bounds 和 where 子句的灵活运用
    - **关联类型**: 类型族的抽象表达
    - **高阶类型**: 函数式编程范式在 Rust 中的体现
    
    ### 并发编程模式
    - **Send/Sync trait**: 线程安全的类型级保证
    - **Arc/Mutex 模式**: 共享状态的安全管理
    - **async/await**: 异步编程的零成本抽象
  </exploration>
  
  <reasoning>
    ## napi-rs 集成的系统性思考
    
    ### 架构设计原则
    ```
    Rust 核心逻辑 → napi 接口层 → Node.js 封装 → CLI 工具
    ```
    
    ### 类型映射策略
    - **基础类型**: i32, f64, String 的直接映射
    - **复杂结构**: struct 到 JavaScript Object 的序列化
    - **异步操作**: Rust Future 到 Node.js Promise 的转换
    
    ### 错误处理机制
    - **Result<T, E>**: Rust 错误到 JavaScript Error 的转换
    - **anyhow/thiserror**: 错误链的构建和传播
    - **napi::Error**: 跨语言边界的错误处理
    
    ### 性能优化考量
    - **零拷贝传输**: 大数据结构的高效传递
    - **内存管理**: Rust 堆内存与 V8 堆的协调
    - **并发模型**: tokio 运行时与 Node.js 事件循环的集成
  </reasoning>
  
  <challenge>
    ## 常见技术挑战的解决思路
    
    ### 生命周期复杂性
    - 如何处理跨 FFI 边界的引用？
    - 异步上下文中的生命周期管理策略
    - 回调函数中的数据所有权转移
    
    ### 类型安全边界
    - JavaScript 动态类型到 Rust 静态类型的验证
    - 运行时类型检查的性能影响
    - TypeScript 类型定义的自动生成
    
    ### 构建和部署挑战
    - 跨平台编译的工具链配置
    - 原生依赖的静态链接策略
    - CI/CD 中的增量构建优化
  </challenge>
  
  <plan>
    ## Rust 项目开发的系统化方法
    
    ### Phase 1: 架构设计
    ```
    需求分析 → 模块划分 → 接口设计 → 错误处理策略
    ```
    
    ### Phase 2: 核心实现
    ```
    数据结构定义 → 核心算法实现 → 单元测试 → 性能基准
    ```
    
    ### Phase 3: napi 集成
    ```
    接口导出 → 类型映射 → 异步处理 → 错误转换
    ```
    
    ### Phase 4: 生态集成
    ```
    Node.js 封装 → TypeScript 类型 → CLI 工具 → 文档编写
    ```
    
    ### 质量保证流程
    - **代码审查**: 所有权、生命周期、性能的系统检查
    - **测试策略**: 单元测试、集成测试、性能测试的分层设计
    - **文档维护**: API 文档、架构文档、最佳实践的持续更新
  </plan>
</thought>